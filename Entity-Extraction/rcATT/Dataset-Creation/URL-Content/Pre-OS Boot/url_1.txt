Booting In computing, booting is the process of starting a computer as initiated via hardware such as a button or by a software command. After it is switched on, a computer's central processing unit (CPU) has no software in its main memory, so some process must load software into memory before it can be executed. This may be done by hardware or firmware in the CPU, or by a separate processor in the computer system. Restarting a computer also is called rebooting, which can be "hard", e.g. after electrical power to the CPU is switched from off to on, or "soft", where the power is not cut. On some systems, a soft boot may optionally clear RAM to zero. Both hard and soft booting can be initiated by hardware such as a button press or by a software command. Booting is complete when the operative runtime system, typically the operating system and some applications,[nb 1] is attained. The process of returning a computer from a state of sleep (suspension) does not involve booting; however, restoring it from a state of hibernation does. Minimally, some embedded systems do not require a noticeable boot sequence to begin functioning and when turned on may simply run operational programs that are stored in ROM. All computing systems are state machines, and a reboot may be the only method to return to a designated zero-state from an unintended, locked state. In addition to loading an operating system or stand-alone utility, the boot process can also load a storage dump program for diagnosing problems in an operating system. Boot is short for bootstrap[1][2] or bootstrap load and derives from the phrase to pull oneself up by one's bootstraps.[3][4] The usage calls attention to the requirement that, if most software is loaded onto a computer by other software already running on the computer, some mechanism must exist to load the initial software onto the computer.[5] Early computers used a variety of ad-hoc methods to get a small program into memory to solve this problem. The invention of read-only memory (ROM) of various types solved this paradox by allowing computers to be shipped with a start up program that could not be erased. Growth in the capacity of ROM has allowed ever more elaborate start up procedures to be implemented. History[edit] There are many different methods available to load a short initial program into a computer. These methods reach from simple, physical input to removable media that can hold more complex programs. Pre integrated-circuit-ROM examples[edit] Early computers[edit] Early computers in the 1940s and 1950s were one-of-a-kind engineering efforts that could take weeks to program and program loading was one of many problems that had to be solved. An early computer, ENIAC, had no program stored in memory, but was set up for each problem by a configuration of interconnecting cables. Bootstrapping did not apply to ENIAC, whose hardware configuration was ready for solving problems as soon as power was applied. The EDSAC system, the second stored-program computer to be built, used stepping switches to transfer a fixed program into memory when its start button was pressed. The program stored on this device, which David Wheeler completed in late 1948, loaded further instructions from punched tape and then executed them.[6][7] First commercial computers[edit] The first programmable computers for commercial sale, such as the UNIVAC I and the IBM 701[8] included features to make their operation simpler. They typically included instructions that performed a complete input or output operation. The same hardware logic could be used to load the contents of a punch card (the most typical ones) or other input media, such as a magnetic drum or magnetic tape, that contained a bootstrap program by pressing a single button. This booting concept was called a variety of names for IBM computers of the 1950s and early 1960s, but IBM used the term "Initial Program Load" with the IBM 7030 Stretch[9] and later used it for their mainframe lines, starting with the System/360 in 1964. The IBM 701 computer (1952â€“1956) had a "Load" button that initiated reading of the first 36-bit word into main memory from a punched card in a card reader, a magnetic tape in a tape drive, or a magnetic drum unit, depending on the position of the Load Selector switch. The left 18-bit half-word was then executed as an instruction, which usually read additional words into memory.[10][11] The loaded boot program was then executed, which, in turn, loaded a larger program from that medium into memory without further help from the human operator. The term "boot" has been used in this sense since at least 1958.[12] Other IBM computers of that era had similar features. For example, the IBM 1401 system (c. 1958) used a card reader to load a program from a punched card. The 80 characters stored in the punched card were read into memory locations 001 to 080, then the computer would branch to memory location 001 to read its first stored instruction. This instruction was always the same: move the information in these first 80 memory locations to an assembly area where the information in punched cards 2, 3, 4, and so on, could be combined to form the stored program. Once this information was moved to the assembly area, the machine would branch to an instruction in location 080 (read a card) and the next card would be read and its information processed. Another example was the IBM 650 (1953), a decimal machine, which had a group of ten 10-position switches on its operator panel which were addressable as a memory word (address 8000) and could be executed as an instruction. Thus setting the switches to 7004000400 and pressing the appropriate button would read the first card in the card reader into memory (op code 70), starting at address 400 and then jump to 400 to begin executing the program on that card.[13] IBM's competitors also offered single button program load. - The CDC 6600 (c. 1964) had a dead start panel with 144 toggle switches; the dead start switch entered 12 words from the toggle switches to the memory of peripheral processor (PP) 0 and initiated the load sequence. PP 0 loaded the necessary code into its own memory and then initialized the other PPs. - The GE 645 (c. 1965) had a "SYSTEM BOOTLOAD" button that, when pressed, caused one of the I/O controllers to load a 64-word program into memory from a diode read-only memory and deliver an interrupt to cause that program to start running.[14] - The first model of the PDP-10 had a "READ IN" button that, when pressed, reset the processor and started an I/O operation on a device specified by switches on the control panel, reading in a 36-bit word giving a target address and count for subsequent word reads; when the read completed, the processor started executing the code read in by jumping to the last word read in.[15] A noteworthy variation of this is found on the Burroughs B1700 where there is neither a bootstrap ROM nor a hardwired IPL operation. Instead, after the system is reset it reads and executes opcodes sequentially from a tape drive mounted on the front panel; this sets up a boot loader in RAM which is then executed. However, since this makes few assumptions about the system it can equally well be used to load diagnostic (Maintenance Test Routine) tapes which display an intelligible code on the front panel even in cases of gross CPU failure. IBM System/360 and successors[edit] In the IBM System/360 and its successors, including the current z/Architecture machines, the boot process is known as Initial Program Load (IPL). IBM coined this term for the 7030 (Stretch),[9] revived it for the design of the System/360, and continues to use it in those environments today.[16] In the System/360 processors, an IPL is initiated by the computer operator by selecting the three hexadecimal digit device address (CUU; C=I/O Channel address, UU=Control unit and Device address[nb 2]) followed by pressing the LOAD button. On the high end System/360 models, most[nb 3] System/370 and some later systems, the functions of the switches and the LOAD button are simulated using selectable areas on the screen of a graphics console, often[nb 4] an IBM 2250-like device or an IBM 3270-like device. For example, on the System/370 Model 158, the keyboard sequence 0-7-X (zero, seven and X, in that order) results in an IPL from the device address which was keyed into the input area. The Amdahl 470V/6 and related CPUs supported four hexadecimal digits on those CPUs which had the optional second channel unit installed, for a total of 32 channels. Later, IBM would also support more than 16 channels. The IPL function in the System/360 and its successors prior to IBM Z, and its compatibles such as Amdahl's, reads 24 bytes from an operator-specified device into main storage starting at real address zero. The second and third groups of eight bytes are treated as Channel Command Words (CCWs) to continue loading the startup program (the first CCW is always simulated by the CPU and consists of a Read IPL command, 02h, with command chaining and suppress incorrect length indication being enforced). When the I/O channel commands are complete, the first group of eight bytes is then loaded into the processor's Program Status Word (PSW) and the startup program begins execution at the location designated by that PSW.[16] The IPL device is usually a disk drive, hence the special significance of the 02h read-type command, but exactly the same procedure is also used to IPL from other input-type devices, such as tape drives, or even card readers, in a device-independent manner, allowing, for example, the installation of an operating system on a brand-new computer from an OS initial distribution magnetic tape. For disk controllers, the 02h command also causes the selected device to seek to cylinder 0000h, head 0000h, simulating a Seek cylinder and head command, 07h, and to search for record 01h, simulating a Search ID Equal command, 31h; seeks and searches are not simulated by tape and card controllers, as for these device classes a Read IPL command is simply a sequential read command. The disk, tape or card deck must contain a special program to load the actual operating system or standalone utility into main storage, and for this specific purpose "IPL Text" is placed on the disk by the stand-alone DASDI (Direct Access Storage Device Initialization) program or an equivalent program running under an operating system, e.g., ICKDSF, but IPL-able tapes and card decks are usually distributed with this "IPL Text" already present. IBM introduced some evolutionary changes in the IPL process, changing some details for System/370 Extended Architecture (S/370-XA) and later, and adding a new type of IPL for z/Architecture. Minicomputers[edit] Minicomputers, starting with the Digital Equipment Corporation (DEC) PDP-5 and PDP-8 (1965) simplified design by using the CPU to assist input and output operations. This saved cost but made booting more complicated than pressing a single button. Minicomputers typically had some way to toggle in short programs by manipulating an array of switches on the front panel. Since the early minicomputers used magnetic core memory, which did not lose its information when power was off, these bootstrap loaders would remain in place unless they were erased. Erasure sometimes happened accidentally when a program bug caused a loop that overwrote all of memory. Other minicomputers with such simple form of booting include Hewlett-Packard's HP 2100 series (mid-1960s), the original Data General Nova (1969), and DEC's PDP-11 (1970). DEC later added an optional diode matrix read-only memory for the PDP-11 that stored a bootstrap program of up to 32 words (64 bytes). It consisted of a printed circuit card, the M792, that plugged into the Unibus and held a 32 by 16 array of semiconductor diodes. With all 512 diodes in place, the memory contained all "one" bits; the card was programmed by cutting off each diode whose bit was to be "zero". DEC also sold versions of the card, the BM792-Yx series, pre-programmed for many standard input devices by simply omitting the unneeded diodes.[17] Following the older approach, the earlier PDP-1 has a hardware loader, such that an operator need only push the "load" switch to instruct the paper tape reader to load a program directly into core memory. The Data General Supernova used front panel switches to cause the computer to automatically load instructions into memory from a device specified by the front panel's data switches, and then jump to loaded code; the Nova 800 and 1200 had a switch that loaded a program into main memory from a special read-only memory and jumped to it.[18] Early minicomputer boot loader examples[edit] In a minicomputer with a paper tape reader, the first program to run in the boot process, the boot loader, would read into core memory either the second-stage boot loader (often called a Binary Loader) that could read paper tape with checksum or the operating system from an outside storage medium. Pseudocode for the boot loader might be as simple as the following eight instructions: - Set the P register to 9 - Check paper tape reader ready - If not ready, jump to 2 - Read a byte from paper tape reader to accumulator - Store accumulator to address in P register - If end of tape, jump to 9 - Increment the P register - Jump to 2 A related example is based on a loader for a Nicolet Instrument Corporation minicomputer of the 1970s, using the paper tape reader-punch unit on a Teletype Model 33 ASR teleprinter. The bytes of its second-stage loader are read from paper tape in reverse order. - Set the P register to 106 - Check paper tape reader ready - If not ready, jump to 2 - Read a byte from paper tape reader to accumulator - Store accumulator to address in P register - Decrement the P register - Jump to 2 The length of the second stage loader is such that the final byte overwrites location 7. After the instruction in location 6 executes, location 7 starts the second stage loader executing. The second stage loader then waits for the much longer tape containing the operating system to be placed in the tape reader. The difference between the boot loader and second stage loader is the addition of checking code to trap paper tape read errors, a frequent occurrence with relatively low-cost, "part-time-duty" hardware, such as the Teletype Model 33 ASR. (Friden Flexowriters were far more reliable, but also comparatively costly.) Booting the first microcomputers[edit] The earliest microcomputers, such as the Altair 8800 (released first in 1975) and an even earlier, similar machine (based on the Intel 8008 CPU) had no bootstrapping hardware as such.[19] When started, the CPU would see memory that would contain executable code containing only binary zerosâ€”memory was cleared by resetting when powering up. The front panels of these machines carried toggle switches for entering addresses and data, one switch per bit of the computer memory word and address bus. Simple additions to the hardware permitted one memory location at a time to be loaded from those switches to store bootstrap code. Meanwhile, the CPU was kept from attempting to execute memory content. Once correctly loaded, the CPU was enabled to execute the bootstrapping code. This process was tedious and had to be error-free.[20] Integrated circuit read-only memory era[edit] The boot process for minicomputers and microcomputers[nb 5] was revolutionized by the introduction of integrated circuit read-only memory (ROM), with its many variants, including mask-programmed ROMs, programmable ROMs (PROM), erasable programmable ROMs (EPROM), and flash memory. These allowed firmware boot programs to be included as part of the computer. The introduction of an (external) ROM was in an Italian telephone switching elaborator, called "Gruppi Speciali", patented in 1975 by Alberto Ciaramella, a researcher at CSELT.[21] Gruppi Speciali was, starting from 1975, a fully single-button machine booting into the operating system from a ROM memory composed from semiconductors, not from ferrite cores. Although the ROM device was not natively embedded in the computer of Gruppi Speciali, due to the design of the machine, it also allowed the single-button ROM booting in machines not designed for that (therefore, this "bootstrap device" was architecture-independent), e.g. the PDP-11. Storing the state of the machine after the switch-off was also in place, which was another critical feature in the telephone switching contest.[22] Typically, every microprocessor will, after a reset or power-on condition, perform a start-up process that usually takes the form of "begin execution of the code that is found starting at a specific address" or "look for a multibyte code at a specific address and jump to the indicated location to begin execution". A system built using that microprocessor will have the permanent ROM occupying these special locations so that the system always begins operating without operator assistance. For example, Intel x86 processors always start by running the instructions beginning at F000:FFF0,[23][24] while for the MOS 6502 processor, initialization begins by reading a two-byte vector address at $FFFD (MS byte) and $FFFC (LS byte) and jumping to that location to run the bootstrap code.[25] Apple Inc.'s first computer, the Apple 1 introduced in 1976, featured PROM chips that eliminated the need for a front panel for the boot process (as was the case with the Altair 8800) in a commercial computer. According to Apple's ad announcing it "No More Switches, No More Lights ... the firmware in PROMS enables you to enter, display and debug programs (all in hex) from the keyboard."[26] Due to the expense of read-only memory at the time, the Apple II series booted its disk operating systems using a series of very small incremental steps, each passing control onward to the next phase of the gradually more complex boot process. (See Apple DOS: Boot loader). Because so little of the disk operating system relied on ROM, the hardware was also extremely flexible and supported a wide range of customized disk copy protection mechanisms. (See Software Cracking: History.) Some operating systems, most notably pre-1995 Macintosh systems from Apple, are so closely interwoven with their hardware that it is impossible to natively boot an operating system other than the standard one. This is the opposite extreme of the scenario using switches mentioned above; it is highly inflexible but relatively error-proof and foolproof as long as all hardware is working normally. A common solution in such situations is to design a boot loader that works as a program belonging to the standard OS that hijacks the system and loads the alternative OS. This technique was used by Apple for its A/UX Unix implementation and copied by various freeware operating systems and BeOS Personal Edition 5. Some machines, like the Atari ST microcomputer, were "instant-on", with the operating system executing from a ROM. Retrieval of the OS from secondary or tertiary store was thus eliminated as one of the characteristic operations for bootstrapping. To allow system customizations, accessories, and other support software to be loaded automatically, the Atari's floppy drive was read for additional components during the boot process. There was a timeout delay that provided time to manually insert a floppy as the system searched for the extra components. This could be avoided by inserting a blank disk. The Atari ST hardware was also designed so the cartridge slot could provide native program execution for gaming purposes as a holdover from Atari's legacy making electronic games; by inserting the Spectre GCR cartridge with the Macintosh system ROM in the game slot and turning the Atari on, it could "natively boot" the Macintosh operating system rather than Atari's own TOS. The IBM Personal Computer included ROM-based firmware called the BIOS; one of the functions of that firmware was to perform a power-on self test when the machine was powered up, and then to read software from a boot device and execute it. Firmware compatible with the BIOS on the IBM Personal Computer is used in IBM PC compatible computers. The UEFI was developed by Intel, originally for Itanium-based machines, and later also used as an alternative to the BIOS in x86-based machines, including Apple Macs using Intel processors. Unix workstations originally had vendor-specific ROM-based firmware. Sun Microsystems later developed OpenBoot, later known as Open Firmware, which incorporated a Forth interpreter, with much of the firmware being written in Forth. It was standardized by the IEEE as IEEE standard 1275-1994; firmware that implements that standard was used in PowerPC-based Macs and some other PowerPC-based machines, as well as Sun's own SPARC-based computers. The Advanced RISC Computing specification defined another firmware standard, which was implemented on some MIPS-based and Alpha-based machines and the SGI Visual Workstation x86-based workstations. Modern boot loaders[edit] When a computer is turned off, its softwareâ€”including operating systems, application code, and dataâ€”remains stored on non-volatile memory. When the computer is powered on, it typically does not have an operating system or its loader in random-access memory (RAM). The computer first executes a relatively small program stored in read-only memory (ROM, and later EEPROM, NOR flash) along with some needed data, to initialize RAM (especially on x86 systems), to access the nonvolatile device (usually block device, e.g. NAND flash) or devices from which the operating system programs and data can be loaded into RAM. The small program that starts this sequence is known as a bootstrap loader, bootstrap or boot loader. Often, multiple-stage boot loaders are used, during which several programs of increasing complexity load one after the other in a process of chain loading. Some earlier computer systems, upon receiving a boot signal from a human operator or a peripheral device, may load a very small number of fixed instructions into memory at a specific location, initialize at least one CPU, and then point the CPU to the instructions and start their execution. These instructions typically start an input operation from some peripheral device (which may be switch-selectable by the operator). Other systems may send hardware commands directly to peripheral devices or I/O controllers that cause an extremely simple input operation (such as "read sector zero of the system device into memory starting at location 1000") to be carried out, effectively loading a small number of boot loader instructions into memory; a completion signal from the I/O device may then be used to start execution of the instructions by the CPU. Smaller computers often use less flexible but more automatic boot loader mechanisms to ensure that the computer starts quickly and with a predetermined software configuration. In many desktop computers, for example, the bootstrapping process begins with the CPU executing software contained in ROM (for example, the BIOS of an IBM PC) at a predefined address (some CPUs, including the Intel x86 series are designed to execute this software after reset without outside help). This software contains rudimentary functionality to search for devices eligible to participate in booting, and load a small program from a special section (most commonly the boot sector) of the most promising device, typically starting at a fixed entry point such as the start of the sector. Boot loaders may face peculiar constraints, especially in size; for instance, on the IBM PC and compatibles, the boot code must fit in the Master Boot Record (MBR) and the Partition Boot Record (PBR), which in turn are limited to a single sector; on the IBM System/360, the size is limited by the IPL medium, e.g., card size, track size. On systems with those constraints, the first program loaded into RAM may not be sufficiently large to load the operating system and, instead, must load another, larger program. The first program loaded into RAM is called a first-stage boot loader, and the program it loads is called a second-stage boot loader. First-stage boot loader[edit] Examples of first-stage (ROM stage or Hardware initialization stage) bootloaders include BIOS, UEFI, coreboot, Libreboot and Das U-Boot. On the IBM PC, the boot loader in the Master Boot Record (MBR) and the Partition Boot Record (PBR) was coded to require at least 32 KB[27][28] (later tightened to 64 KB[29]) of system memory and only use instructions supported by the original 8088/8086 processors. Second-stage boot loader[edit] Second-stage boot loaders, such as GNU GRUB, rEFInd, BOOTMGR, Syslinux, NTLDR or iBoot, are not themselves operating systems, but are able to load an operating system properly and transfer execution to it; the operating system subsequently initializes itself and may load extra device drivers. The second-stage boot loader does not need drivers for its own operation, but may instead use generic storage access methods provided by system firmware such as the BIOS, UEFI or Open Firmware, though typically with restricted hardware functionality and lower performance.[30] Many boot loaders (like GNU GRUB, rEFInd, Windows's BOOTMGR, Syslinux, and Windows NT/2000/XP's NTLDR) can be configured to give the user multiple booting choices. These choices can include different operating systems (for dual or multi-booting from different partitions or drives), different versions of the same operating system (in case a new version has unexpected problems), different operating system loading options (e.g., booting into a rescue or safe mode), and some standalone programs that can function without an operating system, such as memory testers (e.g., memtest86+), a basic shell (as in GNU GRUB), or even games (see List of PC Booter games).[31] Some boot loaders can also load other boot loaders; for example, GRUB loads BOOTMGR instead of loading Windows directly. Usually a default choice is preselected with a time delay during which a user can press a key to change the choice; after this delay, the default choice is automatically run so normal booting can occur without interaction. The boot process can be considered complete when the computer is ready to interact with the user, or the operating system is capable of running system programs or application programs. Many embedded systems must boot immediately. For example, waiting a minute for a digital television or a GPS navigation device to start is generally unacceptable. Therefore, such devices have software systems in ROM or flash memory so the device can begin functioning immediately; little or no loading is necessary, because the loading can be precomputed and stored on the ROM when the device is made. Large and complex systems may have boot procedures that proceed in multiple phases until finally the operating system and other programs are loaded and ready to execute. Because operating systems are designed as if they never start or stop, a boot loader might load the operating system, configure itself as a mere process within that system, and then irrevocably transfer control to the operating system. The boot loader then terminates normally as any other process would. Network booting[edit] Most computers are also capable of booting over a computer network. In this scenario, the operating system is stored on the disk of a server, and certain parts of it are transferred to the client using a simple protocol such as the Trivial File Transfer Protocol (TFTP). After these parts have been transferred, the operating system takes over the control of the booting process. As with the second-stage boot loader, network booting begins by using generic network access methods provided by the network interface's boot ROM, which typically contains a Preboot Execution Environment (PXE) image. No drivers are required, but the system functionality is limited until the operating system kernel and drivers are transferred and started. As a result, once the ROM-based booting has completed it is entirely possible to network boot into an operating system that itself does not have the ability to use the network interface. Personal computers (PC)[edit] Boot devices[edit] The boot device is the device from which the operating system is loaded. A modern PC's UEFI or BIOS firmware supports booting from various devices, typically a local solid state drive or hard disk drive via the GPT or Master Boot Record (MBR) on such a drive or disk, an optical disc drive (using El Torito), a USB mass storage device (FTL-based flash drive, SD card or multi-media card slot, USB hard disk drive, USB optical disc drive, etc.), or a network interface card (using PXE). Older, less common BIOS-bootable devices include floppy disk drives, Zip drives, and LS-120 drives. Typically, the firmware (UEFI or BIOS) will allow the user to configure a boot order. If the boot order is set to "first, the DVD drive; second, the hard disk drive", then the firmware will try to boot from the DVD drive, and if this fails (e.g. because there is no DVD in the drive), it will try to boot from the local hard disk drive. For example, on a PC with Windows installed on the hard drive, the user could set the boot order to the one given above, and then insert a Linux Live CD in order to try out Linux without having to install an operating system onto the hard drive. This is an example of dual booting, in which the user chooses which operating system to start after the computer has performed its Power-on self-test (POST). In this example of dual booting, the user chooses by inserting or removing the DVD from the computer, but it is more common to choose which operating system to boot by selecting from a boot manager menu on the selected device, by using the computer keyboard to select from a BIOS or UEFI Boot Menu, or both; the Boot Menu is typically entered by pressing F8 or F12 keys during the POST; the BIOS Setup is typically entered by pressing F2 or DEL keys during the POST.[32][33] Several devices are available that enable the user to quick-boot into what is usually a variant of Linux for various simple tasks such as Internet access; examples are Splashtop and Latitude ON.[34][35][36] Boot sequence[edit] Upon starting, an IBM-compatible personal computer's x86 CPU, executes in real mode, the instruction located at reset vector (the physical memory address FFFF0h on 16-bit x86 processors[37] and FFFFFFF0h on 32-bit and 64-bit x86 processors[38][39]), usually pointing to the firmware (UEFI or BIOS) entry point inside the ROM. This memory location typically contains a jump instruction that transfers execution to the location of the firmware (UEFI or BIOS) start-up program. This program runs a power-on self-test (POST) to check and initialize required devices such as main memory (DRAM), the PCI bus and the PCI devices (including running embedded Option ROMs). One of the most involved steps is setting up DRAM over SPD, further complicated by the fact that at this point memory is very limited. After initializing required hardware, the firmware (UEFI or BIOS) goes through a pre-configured list of non-volatile storage devices ("boot device sequence") until it finds one that is bootable. A bootable MBR device is defined as one that can be read from, and where the last two bytes of the first sector contain the little-endian word AA55h,[nb 6] found as byte sequence 55h, AAh on disk (also known as the MBR boot signature), or where it is otherwise established that the code inside the sector is executable on x86 PCs. Once the BIOS has found a bootable device it loads the boot sector to linear address 7C00h (usually segment:offset 0000h:7C00h,[27] but some BIOSes erroneously use 07C0h:0000h[citation needed]) and transfers execution to the boot code. In the case of a hard disk, this is referred to as the Master Boot Record (MBR). The conventional MBR code checks the MBR's partition table for a partition set as bootable[nb 7] (the one with active flag set). If an active partition is found, the MBR code loads the boot sector code from that partition, known as Volume Boot Record (VBR), and executes it. The MBR boot code is often operating-system specific. The boot sector code is the first-stage boot loader. It is located on fixed disks and removable drives, and must fit into the first 446 bytes of the Master Boot Record in order to leave room for the default 64-byte partition table with four partition entries and the two-byte boot signature, which the BIOS requires for a proper boot loader â€” or even less, when additional features like more than four partition entries (up to 16 with 16 bytes each), a disk signature (6 bytes), a disk timestamp (6 bytes), an Advanced Active Partition (18 bytes) or special multi-boot loaders have to be supported as well in some environments. In floppy and superfloppy Volume Boot Records, up to 59 bytes are occupied for the Extended BIOS Parameter Block on FAT12 and FAT16 volumes since DOS 4.0, whereas the FAT32 EBPB introduced with DOS 7.1 requires even 87 bytes, leaving only 423 bytes for the boot loader when assuming a sector size of 512 bytes. Microsoft boot sectors therefore traditionally imposed certain restrictions on the boot process, for example, the boot file had to be located at a fixed position in the root directory of the file system and stored as consecutive sectors,[40][41] conditions taken care of by the SYS command and slightly relaxed in later versions of DOS.[41][nb 8] The boot loader was then able to load the first three sectors of the file into memory, which happened to contain another embedded boot loader able to load the remainder of the file into memory.[41] When Microsoft added LBA and FAT32 support, they even switched to a boot loader reaching over two physical sectors and using 386 instructions for size reasons. At the same time other vendors managed to squeeze much more functionality into a single boot sector without relaxing the original constraints on only minimal available memory (32 KB) and processor support (8088/8086).[nb 9] For example, DR-DOS boot sectors are able to locate the boot file in the FAT12, FAT16 and FAT32 file system, and load it into memory as a whole via CHS or LBA, even if the file is not stored in a fixed location and in consecutive sectors.[42][27][43][44][45][nb 10][nb 9] The VBR is often OS-specific; however, its main function is to load and execute the operating system boot loader file (such as bootmgr or ntldr), which is the second-stage boot loader, from an active partition. Then the boot loader loads the OS kernel from the storage device. If there is no active partition, or the active partition's boot sector is invalid, the MBR may load a secondary boot loader which will select a partition (often via user input) and load its boot sector, which usually loads the corresponding operating system kernel. In some cases, the MBR may also attempt to load secondary boot loaders before trying to boot the active partition. If all else fails, it should issue an INT 18h[29][27] BIOS interrupt call (followed by an INT 19h just in case INT 18h would return) in order to give back control to the BIOS, which would then attempt to boot off other devices, attempt a remote boot via network.[27] Many modern systems (Intel Macs and newer PCs) use UEFI.[46][47] Unlike BIOS, UEFI (not Legacy boot via CSM) does not rely on boot sectors, UEFI system loads the boot loader (EFI application file in USB disk or in the EFI System Partition) directly,[48] and the OS kernel is loaded by the boot loader. Other kinds of boot sequences[edit] Some modern CPUs and microcontrollers (for example, TI OMAP) or sometimes even DSPs may have boot ROM with boot code integrated directly into their silicon, so such a processor could perform quite a sophisticated boot sequence on its own and load boot programs from various sources like NAND flash, SD or MMC card and so on. It is difficult to hardwire all the required logic for handling such devices, so an integrated boot ROM is used instead in such scenarios. Boot ROM usage enables more flexible boot sequences than hardwired logic could provide. For example, the boot ROM could try to perform boot from multiple boot sources. Also, a boot ROM is often able to load a boot loader or diagnostic program via serial interfaces like UART, SPI, USB and so on. This feature is often used for system recovery purposes when for some reasons usual boot software in non-volatile memory got erased, and it could also be used for initial non-volatile memory programming when there is clean non-volatile memory installed and hence no software available in the system yet. Some embedded system designs may also include an intermediary boot sequence step in form of additional code that gets loaded into system RAM by the integrated boot ROM. Additional code loaded that way usually serves as a way for overcoming platform limitations, such as small amounts of RAM, so a dedicated primary boot loader, such as Das U-Boot, can be loaded as the next step in system's boot sequence. The additional code and boot sequence step are usually referred to as secondary program loader (SPL).[49] It is also possible to take control of a system by using a hardware debug interface such as JTAG. Such an interface may be used to write the boot loader program into bootable non-volatile memory (e.g. flash) by instructing the processor core to perform the necessary actions to program non-volatile memory. Alternatively, the debug interface may be used to upload some diagnostic or boot code into RAM, and then to start the processor core and instruct it to execute the uploaded code. This allows, for example, the recovery of embedded systems where no software remains on any supported boot device, and where the processor does not have any integrated boot ROM. JTAG is a standard and popular interface; many CPUs, microcontrollers and other devices are manufactured with JTAG interfaces (as of 2009). Some microcontrollers provide special hardware interfaces which cannot be used to take arbitrary control of a system or directly run code, but instead they allow the insertion of boot code into bootable non-volatile memory (like flash memory) via simple protocols. Then at the manufacturing phase, such interfaces are used to inject boot code (and possibly other code) into non-volatile memory. After system reset, the microcontroller begins to execute code programmed into its non-volatile memory, just like usual processors are using ROMs for booting. Most notably this technique is used by Atmel AVR microcontrollers, and by others as well. In many cases such interfaces are implemented by hardwired logic. In other cases such interfaces could be created by software running in integrated on-chip boot ROM from GPIO pins. Most digital signal processors have a serial mode boot, and a parallel mode boot, such as the host port interface (HPI boot). In case of DSPs there is often a second microprocessor or microcontroller present in the system design, and this is responsible for overall system behavior, interrupt handling, dealing with external events, user interface, etc. while the DSP is dedicated to signal processing tasks only. In such systems the DSP could be booted by another processor which is sometimes referred as the host processor (giving name to a Host Port). Such a processor is also sometimes referred as the master, since it usually boots first from its own memories and then controls overall system behavior, including booting of the DSP, and then further controlling the DSP's behavior. The DSP often lacks its own boot memories and relies on the host processor to supply the required code instead. The most notable systems with such a design are cell phones, modems, audio and video players and so on, where a DSP and a CPU/microcontroller are co-existing. Many FPGA chips load their configuration from an external serial EEPROM ("configuration ROM") on power-up. See also[edit] |Look up bootup in Wiktionary, the free dictionary.| - Boot disk - Bootkit - Comparison of boot loaders - Linux startup process - Macintosh startup - Microreboot - Multi boot - Network booting - RedBoot - Self-booting disk - Windows NT startup process - Windows Vista startup process Notes[edit] - ^ Including daemons. - ^ UU was often of the form Uu, U=Control unit address, u=Device address, but some control units attached only 8 devices; some attached more than 16. Indeed, the 3830 DASD controller offered 32-drive-addressing as an option. - ^ Excluding the 370/145 and 370/155, which used a 3210 or 3215 console typewriter. - ^ Only the S/360 used the 2250; the 360/85, 370/165 and 370/168 used a keyboard/display device compatible with nothing else. - ^ The IBM 1401, IBM 7090, IBM System/360 and many others did not require keying in a boot loader. The S/360 had a read only storage in most models, although not using integrated circuits. - ^ The signature at offset +1FEhin boot sectors is 55h AAh, that is 55hat offset +1FEhand AAhat offset +1FFh. Since little-endian representation must be assumed in the context of IBM PC compatible machines, this can be written as 16-bit word AA55hin programs for x86 processors (note the swapped order), whereas it would have to be written as 55AAhin programs for other CPU architectures using a big-endian representation. Since this has been mixed up numerous times in books and even in original Microsoft reference documents, this article uses the offset-based byte-wise on-disk representation to avoid any possible misinterpretation. - ^ The active partition may contain a Second-stage boot loader, e.g., OS/2 Boot Manager, rather than an OS. - ^ The PC DOS 5.0 manual incorrectly states that the systen files no longer need to be contiguous. However, for the boot process to work the system files still need to occupy the first two directory entries and the first three sectors of IBMBIO.COM still need to be stored contiguously. SYS continues to take care of these requirements. - ^ a b As an example, while the extended functionality of DR-DOS MBRs and boot sectors compared to their MS-DOS/PC DOS counterparts could still be achieved utilizing conventional code optimization techniques in assembly language up to 7.05, for the addition of LBA, FAT32 and LOADER support the 7.07 sectors had to resort to self-modifying code, opcode-level programming in machine language, controlled utilization of (documented) side effects, multi-level data/code overlapping and algorithmic folding techniques to squeeze everything into a single physical sector, as it was a requirement for backward- and cross-compatibility with other operating systems in multi-boot and chain load scenarios. - ^ There is one exception to the rule that DR-DOS VBRs will load the whole IBMBIO.COM file into memory: If the IBMBIO.COM file is larger than some 29 KB, trying to load the whole file into memory would result in the boot loader to overwrite the stack and relocated Disk Parameter Table (DPT/FDPB). Therefore, a DR-DOS 7.07 VBR would only load the first 29 KB of the file into memory, relying on another loader embedded into the first part of IBMBIO.COM to check for this condition and load the remainder of the file into memory by itself if necessary. This does not cause compatibility problems, as IBMBIO.COM's size never exceeded this limit in previous versions without this loader. Combined with a dual entry structure this also allows the system to be loaded by a PC DOS VBR, which would load only the first three sectors of the file into memory. References[edit] - ^ "bootstrap". Computer Dictionary of Information Technology. - ^ "Bootstrap". The Free Dictionary. - ^ "Pull oneself up by bootstraps". Idioms by The Free Dictionary. Retrieved 2019-10-07. - ^ "Bootstrap Definition". Tech Terms. Retrieved 2019-10-02. - ^ "Pull yourself up by your bootstraps". The Phrase Finder. - ^ Campbell-Kelly, Martin (1980). "Programming the EDSAC". IEEE Annals of the History of Computing. 2 (1): 7â€“36. doi:10.1109/mahc.1980.10009. - ^ Wilkes, Maurice V.; Wheeler, David J.; Gill, Stanley (1951). The Preparation of Programs for an Electronic Digital Computer. Addison-Wesley. - ^ Buchholz, Werner (1953). "The System Design of the IBM Type 701 Computer" (PDF). Proceedings of the I.R.E. 41 (10): 1273. - ^ a b "IBM 7619 Exchange". Reference Manual 7030 Data Processing System (PDF). IBM. August 1961. pp. 125â€“127. A22-6530-2. - ^ Principles of Operation Type 701 And Associated Equipment (PDF). IBM. 1953. p. 26. Retrieved 2012-11-09. - ^ From Gutenberg to the Internet, Jeremy M. Norman, 2005, page 436, ISBN 0-930405-87-0 - ^ Oxford English Dictionary. Oxford University. - ^ 650 magnetic drum data-processing machine manual of operation (PDF). IBM. 1955. pp. 49, 53â€“54. - ^ GE-645 System Manual (PDF). General Electric. January 1968. Retrieved 2019-10-30. - ^ PDP-10 System Reference Manual, Part 1 (PDF). Digital Equipment Corporation. 1969. pp. 2â€“72. Retrieved 2012-11-09. - ^ a b z/Architecture Principles of Operation (PDF). IBM. September 2005. pp. Chapter 17. Retrieved 2007-04-14. - ^ PDP-11 Peripherals Handbook (PDF). Digital Equipment Corporation. 1976. pp. 4â€“25. - ^ How To Use The Nova Computers (PDF). Data General. October 1974. Section 2.8 "Program Loading". - ^ "Oldcomputers: Altair 8800b". Retrieved 2019-12-10. - ^ Holmer, Glenn. Altair 8800 loads 4K BASIC from paper tape. - ^ Ciaramella, Alberto. "Device for automatically loading the central memory of electronic processors." U.S. Patent No. 4,117,974. 1978-10-03. (submitted in 1975) - ^ Alberto Ciaramella racconta il brevetto del boostrap dei computer concepito in CSELT [Alberto Ciaramella discusses the patent for bootstrapping computers conceived at CSELT] (in Italian). Archived from the original on 2021-11-13. - ^ Osborne, Adam; Kane, Gerry (1981). Osborne 16-Bit Microprocessor Handbook (PDF). pp. 5â€“27. ISBN 0-931988-43-8. Retrieved 2019-08-23. - ^ Intel 64 and IA-32 Architectures Software Developer's Manual Volume 3 (3A, 3B, 3C & 3D): System Programming Guide (PDF). - ^ Osborne, Adam; Kane, Gerry. Osborne 4&8-Bit Microprocessor Handbook. pp. 10â€“20. ISBN 0-931988-42-X. - ^ Apple Ad, Interface Age, October 1976 - ^ a b c d e Paul, Matthias R. (1997-10-02) [1997-09-29]. "Caldera OpenDOS 7.01/7.02 Update Alpha 3 IBMBIO.COM - README.TXT and BOOT.TXT - A short description of how OpenDOS is booted". Archived from the original on 2003-10-04. Retrieved 2009-03-29. [1] - ^ Sakamoto, Masahiko (2010-05-13). "Why BIOS loads MBR into 7C00h in x86?". Glamenv-Septzen.net. Retrieved 2012-08-22. - ^ a b Compaq Computer Corporation; Phoenix Technologies Ltd; Intel Corporation (1996-01-11). "BIOS Boot Specification 1.01" (PDF). Retrieved 2017-12-21. - ^ "Chapter 6 - Troubleshooting Startup and Disk Problems". Windows NT Server Resource Kit. Microsoft. Archived from the original on 2007-05-15. - ^ "Tint". coreboot. Retrieved 2010-11-20. - ^ "List of PC brands with their corresponding hot-keys". www.disk-image.com. Retrieved 2020-09-26. - ^ "How to Enter the BIOS on Any PC: Access Keys by Manufacturer | Tom's Hardware". www.tomshardware.com. Retrieved 2020-09-26. - ^ Brown, Eric (2008-10-02). "MontaVista Linux drives Dell's quick-boot feature". linuxdevices.com. Retrieved 2010-11-20. - ^ Larabel, Michael (2008-06-14). "SplashTop Linux On HP, Dell Notebooks?". Phoronix. Retrieved 2010-11-20. - ^ "Voodoo Envy's Instant-On IOS (powered by Splashtop)". YouTube. Archived from the original on 2021-11-13. Retrieved 2010-11-20. - ^ "iAPX 286 Programmer's Reference Manual" (PDF). Intel. 1983. Section 5.3 SYSTEM INITIALIZATION, p. 5-7. Retrieved 2019-08-23. Since the CS register contains F000 (thus specifying a code segment starting at physical address F0000) and the instruction pointer contains FFF0, the processor will execute its first instruction at physical address FFFF0H. - ^ "80386 Programmer's Reference Manual" (PDF). Intel. 1986. Section 10.2.3 First Instructions, p. 10-3. Retrieved 2013-11-03. After RESET, address lines A31-20 are automatically asserted for instruction fetches. This fact, together with the initial values of CS:IP, causes instruction execution to begin at physical address FFFFFFF0H. - ^ "Intel 64 and IA-32 Architectures Software Developer's Manual" (PDF). Intel Corporation. May 2012. Section 9.1.4 First Instruction Executed, p. 2611. Retrieved 2012-08-23. The first instruction that is fetched and executed following a hardware reset is located at physical address FFFFFFF0h. This address is 16 bytes below the processor's uppermost physical address. The EPROM containing the software-initialization code must be located at this address. - ^ Zbikowski, Mark; Allen, Paul; Ballmer, Steve; Borman, Reuben; Borman, Rob; Butler, John; Carroll, Chuck; Chamberlain, Mark; Chell, David; Colee, Mike; Courtney, Mike; Dryfoos, Mike; Duncan, Rachel; Eckhardt, Kurt; Evans, Eric; Farmer, Rick; Gates, Bill; Geary, Michael; Griffin, Bob; Hogarth, Doug; Johnson, James W.; Kermaani, Kaamel; King, Adrian; Koch, Reed; Landowski, James; Larson, Chris; Lennon, Thomas; Lipkie, Dan; McDonald, Marc; McKinney, Bruce; Martin, Pascal; Mathers, Estelle; Matthews, Bob; Melin, David; Mergentime, Charles; Nevin, Randy; Newell, Dan; Newell, Tani; Norris, David; O'Leary, Mike; O'Rear, Bob; Olsson, Mike; Osterman, Larry; Ostling, Ridge; Pai, Sunil; Paterson, Tim; Perez, Gary; Peters, Chris; Petzold, Charles; Pollock, John; Reynolds, Aaron; Rubin, Darryl; Ryan, Ralph; Schulmeisters, Karl; Shah, Rajen; Shaw, Barry; Short, Anthony; Slivka, Ben; Smirl, Jon; Stillmaker, Betty; Stoddard, John; Tillman, Dennis; Whitten, Greg; Yount, Natalie; Zeck, Steve (1988). "Technical advisors". The MS-DOS Encyclopedia: versions 1.0 through 3.2. By Duncan, Ray; Bostwick, Steve; Burgoyne, Keith; Byers, Robert A.; Hogan, Thom; Kyle, Jim; Letwin, Gordon; Petzold, Charles; Rabinowitz, Chip; Tomlin, Jim; Wilton, Richard; Wolverton, Van; Wong, William; Woodcock, JoAnne (Completely reworked ed.). Redmond, Washington, USA: Microsoft Press. ISBN 1-55615-049-0. LCCN 87-21452. OCLC 16581341. (xix+1570 pages; 26 cm) (NB. This edition was published in 1988 after extensive rework of the withdrawn 1986 first edition by a different team of authors. [2]) - ^ a b c Chappell, Geoff (January 1994). "Chapter 2: The System Footprint". In Schulman, Andrew; Pedersen, Amorette (eds.). DOS Internals. The Andrew Schulman Programming Series (1st printing, 1st ed.). Addison Wesley Publishing Company. ISBN 978-0-201-60835-9. (xxvi+738+iv pages, 3.5"-floppy [3][4]) Errata: [5][6][7] - ^ Rosch, Winn L. (1991-02-12). "DR DOS 5.0 - The better operating system?". PC Magazine. Vol. 10, no. 3. p. 241-246, 257, 264, 266. Archived from the original on 2019-07-25. Retrieved 2019-07-26. [â€¦] SYS has been improved under DR DOS 5.0 so you don't have to worry about leaving the first cluster free on a disk that you want to make bootable. The DR DOS system files can be located anywhere on the disk, so any disk with enough free space can be set to boot your system. [â€¦](NB. The source attributes this to the SYS utility while in fact this is a feature of the advanced bootstrap loader in the boot sector. SYS just plants this sector onto the disk.) - ^ Paul, Matthias R. (2001-01-17). "FAT32 in DR-DOS". opendos@delorie. Archived from the original on 2017-10-06. Retrieved 2017-10-06. [â€¦] The DR-DOS boot sector [â€¦] searches for the IBMBIO.COM (DRBIOS.SYS) file and then loads the *whole* file into memory before it passes control to it. [â€¦] - ^ Paul, Matthias R. (2002-02-20). "Can't copy". opendos@delorie. Archived from the original on 2017-10-06. Retrieved 2017-10-06. [â€¦] The DR-DOS boot sector loads the whole IBMBIO.COM file into memory before it executes it. It does not care at all about the IBMDOS.COM file, which is loaded by IBMBIO.COM. [â€¦] The DR-DOS boot sector [â€¦] will find the [â€¦] kernel files as long as they are logically stored in the root directory. Their physical location on the disk, and if they are fragmented or not, is don't care for the DR-DOS boot sector. Hence, you can just copy the kernel files to the disk (even with a simply COPY), and as soon as the boot sector is a DR-DOS sector, it will find and load them. Of course, it is difficult to put all this into just 512 bytes, the size of a single sector, but this is a major convenience improvement if you have to set up a DR-DOS system, and it is also the key for the DR-DOS multi-OS LOADER utility to work. The MS-DOS kernel files must reside on specific locations, but the DR-DOS files can be anywhere, so you don't have to physically swap them around each time you boot the other OS. Also, it allows to upgrade a DR-DOS system simply by copying the kernel files over the old ones, no need for SYS, no difficult setup procedures as required for MS-DOS/PC DOS. You can even have multiple DR-DOS kernel files under different file names stored on the same drive, and LOADER will switch between them according to the file names listed in the BOOT.LST file. [â€¦] - ^ Paul, Matthias R. (2017-08-14) [2017-08-07]. "The continuing saga of Windows 3.1 in enhanced mode on OmniBook 300". MoHPC - the Museum of HP Calculators. Archived from the original on 2017-10-06. Retrieved 2017-10-06. [â€¦] the DR-DOS FDISK does not only partition a disk, but can also format the freshly created volumes and initialize their boot sectors in one go, so there's no risk to accidentally mess up the wrong volume and no need for FORMAT /S or SYS. Afterwards, you could just copy over the remaining DR-DOS files, including the system files. It is important to know that, in contrast to MS-DOS/PC DOS, DR-DOS has "smart" boot sectors which will actually "mount" the file-system to search for and load the system files in the root directory instead of expecting them to be placed at a certain location. Physically, the system files can be located anywhere and also can be fragmented. [â€¦] - ^ "Intel Platform Innovation Framework for EFI". Intel. Retrieved 2008-01-07. - ^ "OpenBIOS - coreboot". coreboot.org. Retrieved 2013-03-20. - ^ "UEFI - OSDev Wiki". wiki.osdev.org. Retrieved 2020-09-26. - ^ "Overview â€“ The four bootloader stages". ti.com. Texas Instruments. 2013-12-05. Retrieved 2015-01-25.