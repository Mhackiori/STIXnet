Some times ago my antivirus didn’t recognize a malware on my machine; the malware installed a keylogger and it did run silently in background for some hours. In general, you can discover the presence of a keylogger looking at the net traffic log or looking for some suspicious file name inside the task manager list but sometimes an application able to find out hooks will come in handy. At first I tried to find some informations browsing the net without luck. Hmm, no one has written such a program before? Is it possible or am I unable to use google??? I only got one usefull hint about the problem, nothing else. Well, I decided to take a look at the problem. All my investigations are done under Windows XP/SP1. Before starting with the analysis I want to show you the declaration of the function used to set a windows hook: HHOOK SetWindowsHookEx( int idHook, // Specifies the type of hook procedure to be installed. HOOKPROC lpfn, // Pointer to the hook procedure HINSTANCE hMod, // Handle to the DLL containing the hook procedure pointed to by the lpfn parameter DWORD dwThreadId // Specifies the identifier of the thread with which the hook procedure is to be associated ); It’s always good to know which parameters are passed to the function because you’ll have to deal with them later. Ok, time to start… A possible starting point is represented by win32k.sys file, it’s everything inside it. Looking at the implementation of SetWindowsHookEx I’ve seen a call to HMAllocObject. This function is not really known but if you have ever read ‘Using Softice’ help file you surely read the phrase: “The routine HMAllocObject creates USER object types…”. Interesting, setting a bpx over the function I got the following informations: .text:BF853AAB push 34h ; nBytes .text:BF853AAD push 5 ; TYPE_HOOK .text:BF853AAF push dword ptr [edi+3Ch] ; PTHREADINFO.rpdesk .text:BF853AB2 push edi ; PTHREADINFO .text:BF853AB3 call _HMAllocObject@16 ; HMAllocObject(x,x,x,x) The function takes four parameters and the 3° parameter is related with the type of object that is created. In this specific case I’m dealing with hook so the type is TYPE_HOOK and HMAllocObject returns a pointer to a structure named HOOK, it contains general informations about the new object and it looks like: typedef struct _HOOK { ULONG hHook; ULONG cLockObj; PTHREADINFO pti; ULONG rpdesk; ULONG pSelf; struct _HOOK *phkNext; int iHook; ULONG offPfn; unsigned int flags; int ihmod; PTHREADINFO ptiHooked; PDESKTOP rpdesk; } HOOK, *PHOOK; Fields: – hHook Handle to the hook procedure, it’s the value returned by SetWindowsHookEx and it comes from HMAllocObject – clockObj !?! – pti Pointer to THREADINFO structure of the process which sets the hook – rpdesk !?! – pSelf Pointer to this HOOK structure – phkNext Next structure in the hook chain – iHook Hook type (i.e. WH_MOUSE or WH_KEYBOARD). This is the first parameter passed to SetWindowsHookEx – offPfn Offset of the filter procedure, it is obtained by a simple substration between the address of the hook procedure and the initial address of the dll – flags HF_xxx flags (HF_GLOBALS, HF_LOCAL, HF_DESTROYED…) – ihmod Number of hooks set into the module – ptiHooked Pointer to THREADINFO structure of the hooked thread. If HF_GLOBAL is setted the pointer is setted to NULL because the hook works for every running thread – rpdesk !?! As you can see the fields are not all explained, I’ll try to gain more informations. Some of the fields are filled by HMAllocObject itself and they are non TYPE_HOOK related field; I mean, the HOOK structure contains informations about the hook you want to install (i.e. the hook type, the offset of the filter procedure) and informations not so strictly related with the hook (i.e. phkNext, pSelf). Since of all the work is done trying to understand if there are global hooks installed on the system I’m only interested in TYPE_HOOK related fields and these are: 1. pti pti is really usefull because it gives me the possibility to access the process that has installed the hook. The first dword of THREADINFO structure is the pointer to ETHREAD structure which contains a pointer to EPROCESS structure. Once you have EPROCESS you can read the image file name (Imagfilename field) and the pid (UniqueProcessId) of the process that has setted the hook. At this point you can also read which dlls are loaded by the process or get any other usefull informations about it, especially which dll has the filter procedure inside. If you are not totally confident with undocumented structures you can even retrieve the informations using functions from Psapi library (i.e. EnumProcessModules/GetModuleFileNameEx to obtain a loaded dll…). 2. iHook without it you won’t be able to know which hook was installed. 3. offPfn only necessary if you want to know where the filter procedure is located at. Starting from the HOOK structure I can retrieve all the needed informations about the HOOK but I need a fundamental information, maybe the most important one. Where can I find the HOOK structure? As I said before I only got an hint about the problem, it comes from an old thread at sysinternals forum (htt://forum.sysinternals.com/); I don’t remember the name of the user, thanks to him btw. The hint sounds like: “look at aphkStart”, nothing else. aphkStart is defined as: PHOOK aphkStart[CWINHOOKS]; It’s an array of pointers to HOOK structure, one for each possible WH_xxx hook; the pointer at index ‘i’ is NULL if you are not under the hook. As far as I have seen there are two aphkStart arrays, one for local hooks (inside THREADINFO structure) and one for global hooks (inside DESKTOPINFO structure). To find out if a global hook has been installed you only have to scan the entire aphkStart array (the one inside DESKTOPINFO) looking for a not NULL entry, if you find it you are under a global hook. The picture below represents a little sum-up. You start from the TEB of the current process, the process that check the installed hooks. When you have the TEB you can pass through some structures: 1. From TEB.Win32ThreadInfo you get THREADINFO structure 2. From THREADINFO.pDeskInfo you get DESKTOPINFO structure 3. If DESKTOPINFO.aphkStart[i] is not NULL you get HOOK structure of WH_i hook otherwise WH_i hook is not installed and you can check the next one, WH_i+1 4. From HOOK.pti you get THREADINFO structure of the process that has setted the hook 5. From THREADINFO.pEthread you get ETHREAD structure 6. From ETHREAD.ThreadsProcess you get EPROCESS structure Inside EPROCESS there are many informations about the process, just read the necessary ones. Where can I find information relating to the various structs you refer to? e.g. THREADINFO, DESKTOPINFO Thanks I usually use WinDbg or .h file I have on my machine, but the net is a good alternative way. I don’t remember where I got the information about the structure you mentioned, and I don’t have on my hard disk anymore (it’s dead…). If you want to know something more about these specific structures you can use Windbg starting from _TEB (which is visible from Windbg for sure). In case I’ll find the structure’s definitions I’ll tell you. Hello Zairon, Great article! Is there any way you could please post a source code example that you can share to list these hooks on Windows XP? I’m finding that these structures are rather confusing because most of the struct member names are very similar. Hello Zairon, stumbled over this old article of yours and I’m trying to construct a HookExplorer but keep finding my self in the deep end of the pool…. might be in over my head… You couldn’t by any chance post a complete example or mail me some source? Regards I finally get the HOOK struct, I’m interested on global hooks only. I get all information about my machine’s global hooks, but I have no idea how to get the module of the hook procedure, I mean, in the hook struct typedef struct tagHOOK { /* hk */ THRDESKHEAD head; struct tagHOOK* pNext; int iHook; PVOID pfn; UINT flags; int imod; PTHREADINFO ptiHooked; PDESKTOP rpdesk; } HOOK; pfn -> is the offset of the procedure in the module… imod -> I assume that points to a module, but I have no idea how to translate that to a real dll path. help! Hello, great article and great info! I’m not sure what I’m doing wrong. Or maybe I’m missing something. I have gotten all the code to compile, and (using kernel debugger) am able to look at the structure for THREADINFO. The address all look good (refCount of_W32THREAD, pETHREAD, etc… However, my THREADINFO.pDeskInfo has an address of:0xbc640650. At which point, when i try to look at that memory address, i get a bunch of ????. Any clues as to what I could be doing wrong? THANKS! You have saved the day!! I have an app that depends heavily on a thread-specific hook in a listview control in a native C++ app. The OS(XP SP3) was arbitrarily dumping my HookProc and I had no way of easily detecting when the problem occurred. I used the methods in your code to build a DLL that allows me to monitor the status of my HookProc and reset it when necessary. Thanks again… TF Glad to see someone finds it usefull! Thanks to you :) TBFisher, could you PLEASE share sourcecode of the function that checks status of the hook? I have the same problem…